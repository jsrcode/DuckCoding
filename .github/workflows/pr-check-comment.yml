name: PR Check Comment

on:
  workflow_run:
    workflows: ['PR Check']
    types:
      - completed

permissions:
  pull-requests: write

jobs:
  comment:
    name: Update PR Comment
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request'

    steps:
      - name: Download artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // è·å–æ‰€æœ‰ artifacts
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id,
            });

            console.log(`Found ${artifacts.data.artifacts.length} artifacts`);

            // ä¸‹è½½æ‰€æœ‰å¹³å°çš„çŠ¶æ€æ–‡ä»¶
            for (const artifact of artifacts.data.artifacts) {
              if (artifact.name.startsWith('pr-check-state-')) {
                console.log(`Downloading artifact: ${artifact.name}`);

                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                  archive_format: 'zip',
                });

                fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));
              }
            }

      - name: Extract artifacts
        run: |
          mkdir -p states
          for zip in pr-check-state-*.zip; do
            if [ -f "$zip" ]; then
              unzip -o "$zip" -d states/
            fi
          done
          ls -la states/ || true

      - name: Update PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const marker = '<!-- duckcoding-pr-check -->';
            const stateMarker = '<!-- duckcoding-pr-check-state:';
            const platforms = ['ubuntu-22.04', 'windows-latest', 'macos-arm64', 'macos-x64'];

            // è·å– PR ç¼–å·
            const prNumber = context.payload.workflow_run.pull_requests[0]?.number;
            if (!prNumber) {
              console.log('No PR number found, skipping comment update');
              return;
            }

            console.log(`Updating comment for PR #${prNumber}`);

            // è¯»å–æ‰€æœ‰å¹³å°çš„çŠ¶æ€
            const defaultState = () =>
              Object.fromEntries(
                platforms.map((p) => [
                  p,
                  {
                    platform: p,
                    status: 'pending',
                    check: 'pending',
                    fix: 'pending',
                    recheck: 'pending',
                    artifact: '',
                    run_url: ''
                  }
                ])
              );

            let state = defaultState();

            // ä» artifact ä¸­è¯»å–å„å¹³å°çŠ¶æ€
            const statesDir = 'states';
            if (fs.existsSync(statesDir)) {
              for (const platform of platforms) {
                const stateFile = path.join(statesDir, `${platform}.json`);
                if (fs.existsSync(stateFile)) {
                  try {
                    const platformState = JSON.parse(fs.readFileSync(stateFile, 'utf8'));
                    state[platform] = platformState;
                    console.log(`Loaded state for ${platform}:`, platformState);
                  } catch (e) {
                    console.error(`Failed to parse state for ${platform}:`, e);
                  }
                }
              }
            }

            const statusLabelZh = (entry) => {
              if (entry.status === 'pending') return 'â³ è¿è¡Œä¸­...';
              if (entry.status === 'success') return 'âœ… ç›´æ¥é€šè¿‡';
              if (entry.status === 'fix_pass') return 'ğŸŸ¡ è‡ªåŠ¨ä¿®å¤åé€šè¿‡ï¼ˆè¯·æœ¬åœ°æäº¤ä¿®å¤ï¼‰';
              return 'âŒ ä»æœªé€šè¿‡';
            };

            const statusLabelEn = (entry) => {
              if (entry.status === 'pending') return 'â³ In progress...';
              if (entry.status === 'success') return 'âœ… Passed';
              if (entry.status === 'fix_pass') return 'ğŸŸ¡ Passed after auto-fix (commit locally)';
              return 'âŒ Still failing';
            };

            const detail = (entry) =>
              entry.status === 'pending'
                ? '-'
                : `check=${entry.check} / fix=${entry.fix} / recheck=${entry.recheck}`;

            const linkOrDash = (entry) => (entry.run_url ? `[æ—¥å¿—](${entry.run_url})` : '-');
            const artifactOrDash = (entry) => (entry.status === 'pending' ? '-' : entry.artifact || '-');

            const pLabel = (p) => {
              if (p === 'ubuntu-22.04') return 'ubuntu-22.04';
              if (p === 'windows-latest') return 'windows-latest';
              if (p === 'macos-arm64') return 'macos-14 (arm64)';
              if (p === 'macos-x64') return 'macos-15 (x64)';
              return p;
            };

            const renderTable = (labelFn, header) => {
              const rows = platforms
                .map((p) => {
                  const e = state[p] || defaultState()[p];
                  return `| ${pLabel(p)} | ${labelFn(e)} | ${detail(e)} | ${artifactOrDash(e)} | ${linkOrDash(e)} |`;
                })
                .join('\n');
              return [
                `| ${header.platform} | ${header.status} | ${header.detail} | ${header.artifact} | ${header.link} |`,
                '| --- | --- | --- | --- | --- |',
                rows
              ].join('\n');
            };

            const tableZh = renderTable(statusLabelZh, {
              platform: 'å¹³å°',
              status: 'ç»“æœ',
              detail: 'æ˜ç»†',
              artifact: 'æ—¥å¿—åŒ…',
              link: 'è¿è¡Œé“¾æ¥'
            });

            const tableEn = renderTable(statusLabelEn, {
              platform: 'Platform',
              status: 'Status',
              detail: 'Detail',
              artifact: 'Artifact',
              link: 'Run'
            });

            const body = [
              'æœ¬è¯„è®ºä¼šéšå„å¹³å°ä»»åŠ¡å®Œæˆè‡ªåŠ¨æ›´æ–°ï¼š',
              'å¦‚é¦–è½® `npm run check` å¤±è´¥ï¼Œè¯·åœ¨æœ¬åœ°æ‰§è¡Œ `npm run check:fix` â†’ `npm run check` å¹¶æäº¤ä¿®å¤ commitã€‚',
              'å¦‚ fix ä»å¤±è´¥ï¼Œè¯·åœ¨æœ¬åœ°æ’æŸ¥å¹¶ç¡®ä¿ `npm run check` é€šè¿‡åå†æäº¤ã€‚',
              'è·¨å¹³å°å·®å¼‚è‹¥æ— æ³•å¤ç°ï¼Œè¯·å¤åˆ¶æ—¥å¿—äº¤ç»™ AI è·å–æ’æŸ¥å»ºè®®ã€‚',
              '',
              tableZh,
              '',
              '---',
              '',
              'This comment auto-updates as each platform finishes:',
              'If the first `npm run check` fails, run locally: `npm run check:fix` â†’ `npm run check` and commit the fix.',
              'If fix still fails, investigate locally and ensure `npm run check` passes before committing.',
              'If cross-platform issues can't be reproduced, copy logs to an AI for hints.',
              '',
              tableEn,
              marker,
              `${stateMarker}${JSON.stringify(state)} -->`
            ].join('\n');

            // æŸ¥æ‰¾ç°æœ‰è¯„è®º
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const existing = comments.find((c) => c.body.includes(marker));

            if (existing) {
              console.log(`Updating existing comment #${existing.id}`);
              await github.rest.issues.updateComment({
                comment_id: existing.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body
              });
            } else {
              console.log('Creating new comment');
              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body
              });
            }
